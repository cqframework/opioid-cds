<?xml version="1.0" encoding="UTF-8"?>
<library xmlns="urn:hl7-org:elm:r1" xmlns:t="urn:hl7-org:elm-types:r1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:fhir="http://hl7.org/fhir" xmlns:qdm43="urn:healthit-gov:qdm:v4_3" xmlns:qdm53="urn:healthit-gov:qdm:v5_3" xmlns:a="urn:hl7-org:cql-annotations:r1">
   <identifier id="RxSig" version="0.1.0"/>
   <schemaIdentifier id="urn:hl7-org:elm" version="r1"/>
   <usings>
      <def localIdentifier="System" uri="urn:hl7-org:elm-types:r1"/>
   </usings>
   <statements>
      <def name="Patient" context="Population">
         <expression xsi:type="Null"/>
      </def>
      <def name="ReplaceMatchesAlphaWord" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="ReplaceMatches">
            <operand name="phrase" xsi:type="OperandRef"/>
            <operand xsi:type="Concatenate">
               <operand xsi:type="Concatenate">
                  <operand valueType="t:String" value="(?&lt;![a-z])" xsi:type="Literal"/>
                  <operand name="oldWordPattern" xsi:type="OperandRef"/>
               </operand>
               <operand valueType="t:String" value="(?![a-z])" xsi:type="Literal"/>
            </operand>
            <operand name="newWordTemplate" xsi:type="OperandRef"/>
         </expression>
         <operand name="phrase">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="oldWordPattern">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="newWordTemplate">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ReplaceMatchesDigitWord" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="ReplaceMatches">
            <operand name="phrase" xsi:type="OperandRef"/>
            <operand xsi:type="Concatenate">
               <operand xsi:type="Concatenate">
                  <operand valueType="t:String" value="(?&lt;!\d)" xsi:type="Literal"/>
                  <operand name="oldWordPattern" xsi:type="OperandRef"/>
               </operand>
               <operand valueType="t:String" value="(?!\d)" xsi:type="Literal"/>
            </operand>
            <operand name="newWordTemplate" xsi:type="OperandRef"/>
         </expression>
         <operand name="phrase">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="oldWordPattern">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="newWordTemplate">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ReplaceMatchesAlphaDigitWord" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="ReplaceMatches">
            <operand name="phrase" xsi:type="OperandRef"/>
            <operand xsi:type="Concatenate">
               <operand xsi:type="Concatenate">
                  <operand valueType="t:String" value="\b" xsi:type="Literal"/>
                  <operand name="oldWordPattern" xsi:type="OperandRef"/>
               </operand>
               <operand valueType="t:String" value="\b" xsi:type="Literal"/>
            </operand>
            <operand name="newWordTemplate" xsi:type="OperandRef"/>
         </expression>
         <operand name="phrase">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="oldWordPattern">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="newWordTemplate">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="CleanedStr" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="Query">
            <source alias="str">
               <expression name="value" xsi:type="OperandRef"/>
            </source>
            <let identifier="mergeSpaces">
               <expression xsi:type="ReplaceMatches">
                  <operand name="str" xsi:type="AliasRef"/>
                  <operand valueType="t:String" value=" {2,}" xsi:type="Literal"/>
                  <operand valueType="t:String" value=" " xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dropPfxPeriods">
               <expression xsi:type="ReplaceMatches">
                  <operand name="mergeSpaces" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="^[\. ]*" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dropNonNumPeriods">
               <expression xsi:type="ReplaceMatches">
                  <operand name="dropPfxPeriods" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?&lt;=\D)\." xsi:type="Literal"/>
                  <operand valueType="t:String" value=" " xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dropNonNumHyphens1">
               <expression xsi:type="ReplaceMatches">
                  <operand name="dropNonNumPeriods" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?&lt;=[^\d d])-(?=[a-z])" xsi:type="Literal"/>
                  <operand valueType="t:String" value="- " xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dropNonNumHyphens2">
               <expression xsi:type="ReplaceMatches">
                  <operand name="dropNonNumHyphens1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?&lt;=[^\d d])-" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dropSfxPeriodsHyphens">
               <expression xsi:type="ReplaceMatches">
                  <operand name="dropNonNumHyphens2" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="[\. -]*$" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dropEmptyParens">
               <expression xsi:type="ReplaceMatches">
                  <operand name="dropSfxPeriodsHyphens" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="\( *\)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <return>
               <expression name="dropEmptyParens" xsi:type="QueryLetRef"/>
            </return>
         </expression>
         <operand name="value">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="NormalizeYear" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="If">
            <condition asType="t:Boolean" xsi:type="As">
               <operand xsi:type="GreaterOrEqual">
                  <operand name="y" xsi:type="OperandRef"/>
                  <operand valueType="t:Integer" value="100" xsi:type="Literal"/>
               </operand>
            </condition>
            <then name="y" xsi:type="OperandRef"/>
            <else xsi:type="If">
               <condition asType="t:Boolean" xsi:type="As">
                  <operand xsi:type="GreaterOrEqual">
                     <operand name="y" xsi:type="OperandRef"/>
                     <operand valueType="t:Integer" value="40" xsi:type="Literal"/>
                  </operand>
               </condition>
               <then xsi:type="Add">
                  <operand valueType="t:Integer" value="1900" xsi:type="Literal"/>
                  <operand name="y" xsi:type="OperandRef"/>
               </then>
               <else xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="GreaterOrEqual">
                        <operand name="y" xsi:type="OperandRef"/>
                        <operand valueType="t:Integer" value="0" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then xsi:type="Add">
                     <operand valueType="t:Integer" value="2000" xsi:type="Literal"/>
                     <operand name="y" xsi:type="OperandRef"/>
                  </then>
                  <else name="y" xsi:type="OperandRef"/>
               </else>
            </else>
         </expression>
         <operand name="y">
            <operandTypeSpecifier name="t:Integer" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ProcessIgnorableWordPhrase" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="SingletonFrom">
            <operand xsi:type="Query">
               <source alias="S">
                  <expression name="states" xsi:type="OperandRef"/>
               </source>
               <return>
                  <expression xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Matches">
                           <operand path="leftover" scope="S" xsi:type="Property"/>
                           <operand xsi:type="Concatenate">
                              <operand xsi:type="Concatenate">
                                 <operand valueType="t:String" value=".*?\b" xsi:type="Literal"/>
                                 <operand name="phrase" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="\b.*" xsi:type="Literal"/>
                           </operand>
                        </operand>
                     </condition>
                     <then xsi:type="Tuple">
                        <element name="ignorable">
                           <value xsi:type="Concatenate">
                              <operand xsi:type="If">
                                 <condition asType="t:Boolean" xsi:type="As">
                                    <operand xsi:type="IsNull">
                                       <operand path="ignorable" scope="S" xsi:type="Property"/>
                                    </operand>
                                 </condition>
                                 <then valueType="t:String" value="" xsi:type="Literal"/>
                                 <else xsi:type="Concatenate">
                                    <operand path="ignorable" scope="S" xsi:type="Property"/>
                                    <operand valueType="t:String" value="; " xsi:type="Literal"/>
                                 </else>
                              </operand>
                              <operand xsi:type="ReplaceMatches">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand valueType="t:String" value=".*?\b(" xsi:type="Literal"/>
                                       <operand name="phrase" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value=")\b.*" xsi:type="Literal"/>
                                 </operand>
                                 <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                              </operand>
                           </value>
                        </element>
                        <element name="leftover">
                           <value name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                              <operand path="leftover" scope="S" xsi:type="Property"/>
                              <operand name="phrase" xsi:type="OperandRef"/>
                              <operand valueType="t:String" value="" xsi:type="Literal"/>
                           </value>
                        </element>
                     </then>
                     <else name="S" xsi:type="AliasRef"/>
                  </expression>
               </return>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="ignorable">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="phrase">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ProcessWordPrnReasonWithLabel" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="SingletonFrom">
            <operand xsi:type="Query">
               <source alias="S">
                  <expression name="states" xsi:type="OperandRef"/>
               </source>
               <return>
                  <expression xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Matches">
                           <operand path="leftover" scope="S" xsi:type="Property"/>
                           <operand xsi:type="Concatenate">
                              <operand xsi:type="Concatenate">
                                 <operand valueType="t:String" value=".*?\bprn(?: for)? " xsi:type="Literal"/>
                                 <operand name="reasonRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="\b.*" xsi:type="Literal"/>
                           </operand>
                        </operand>
                     </condition>
                     <then xsi:type="Tuple">
                        <element name="isPrn">
                           <value valueType="t:Boolean" value="true" xsi:type="Literal"/>
                        </element>
                        <element name="indication">
                           <value xsi:type="If">
                              <condition asType="t:Boolean" xsi:type="As">
                                 <operand xsi:type="IsNull">
                                    <operand xsi:type="SingletonFrom">
                                       <operand name="reasonLabel" xsi:type="OperandRef"/>
                                    </operand>
                                 </operand>
                              </condition>
                              <then xsi:type="ReplaceMatches">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand valueType="t:String" value=".*?\bprn(?: for)? (" xsi:type="Literal"/>
                                       <operand name="reasonRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value=")\b.*" xsi:type="Literal"/>
                                 </operand>
                                 <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                              </then>
                              <else xsi:type="SingletonFrom">
                                 <operand name="reasonLabel" xsi:type="OperandRef"/>
                              </else>
                           </value>
                        </element>
                        <element name="leftover">
                           <value name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                              <operand path="leftover" scope="S" xsi:type="Property"/>
                              <operand xsi:type="Concatenate">
                                 <operand valueType="t:String" value="prn(?: for)? " xsi:type="Literal"/>
                                 <operand name="reasonRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="" xsi:type="Literal"/>
                           </value>
                        </element>
                     </then>
                     <else name="S" xsi:type="AliasRef"/>
                  </expression>
               </return>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="isPrn">
                     <type name="t:Boolean" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="indication">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="reasonRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="reasonLabel">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType name="t:String" xsi:type="NamedTypeSpecifier"/>
            </operandTypeSpecifier>
         </operand>
      </def>
      <def name="ProcessWordPrnReason" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression name="ProcessWordPrnReasonWithLabel" xsi:type="FunctionRef">
            <operand name="states" xsi:type="OperandRef"/>
            <operand name="reasonRegex" xsi:type="OperandRef"/>
            <operand xsi:type="ToList">
               <operand strict="false" xsi:type="As">
                  <operand xsi:type="Null"/>
                  <asTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
               </operand>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="isPrn">
                     <type name="t:Boolean" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="indication">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="reasonRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ProcessWordIndicationWithLabel" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="SingletonFrom">
            <operand xsi:type="Query">
               <source alias="S">
                  <expression name="states" xsi:type="OperandRef"/>
               </source>
               <return>
                  <expression xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Matches">
                           <operand path="leftover" scope="S" xsi:type="Property"/>
                           <operand xsi:type="Concatenate">
                              <operand xsi:type="Concatenate">
                                 <operand valueType="t:String" value=".*?\b(?:for|indications?) " xsi:type="Literal"/>
                                 <operand name="indicRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="\b.*" xsi:type="Literal"/>
                           </operand>
                        </operand>
                     </condition>
                     <then xsi:type="Tuple">
                        <element name="indication">
                           <value xsi:type="If">
                              <condition asType="t:Boolean" xsi:type="As">
                                 <operand xsi:type="IsNull">
                                    <operand xsi:type="SingletonFrom">
                                       <operand name="indicLabel" xsi:type="OperandRef"/>
                                    </operand>
                                 </operand>
                              </condition>
                              <then xsi:type="ReplaceMatches">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand valueType="t:String" value=".*?\b(?:for|indications?) (" xsi:type="Literal"/>
                                       <operand name="indicRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value=")\b.*" xsi:type="Literal"/>
                                 </operand>
                                 <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                              </then>
                              <else xsi:type="SingletonFrom">
                                 <operand name="indicLabel" xsi:type="OperandRef"/>
                              </else>
                           </value>
                        </element>
                        <element name="leftover">
                           <value name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                              <operand path="leftover" scope="S" xsi:type="Property"/>
                              <operand xsi:type="Concatenate">
                                 <operand valueType="t:String" value="(?:for|indications?) " xsi:type="Literal"/>
                                 <operand name="indicRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="" xsi:type="Literal"/>
                           </value>
                        </element>
                     </then>
                     <else name="S" xsi:type="AliasRef"/>
                  </expression>
               </return>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="indication">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="indicRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="indicLabel">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType name="t:String" xsi:type="NamedTypeSpecifier"/>
            </operandTypeSpecifier>
         </operand>
      </def>
      <def name="ProcessWordIndication" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression name="ProcessWordIndicationWithLabel" xsi:type="FunctionRef">
            <operand name="states" xsi:type="OperandRef"/>
            <operand name="indicRegex" xsi:type="OperandRef"/>
            <operand xsi:type="ToList">
               <operand strict="false" xsi:type="As">
                  <operand xsi:type="Null"/>
                  <asTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
               </operand>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="indication">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="indicRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ProcessWordDuration" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="SingletonFrom">
            <operand xsi:type="Query">
               <source alias="S">
                  <expression name="states" xsi:type="OperandRef"/>
               </source>
               <return>
                  <expression xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Matches">
                           <operand path="leftover" scope="S" xsi:type="Property"/>
                           <operand xsi:type="Concatenate">
                              <operand xsi:type="Concatenate">
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand valueType="t:String" value=".*?\b" xsi:type="Literal"/>
                                       <operand name="prefixRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value=" *\d+ *" xsi:type="Literal"/>
                                 </operand>
                                 <operand name="suffixRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="\b.*" xsi:type="Literal"/>
                           </operand>
                        </operand>
                     </condition>
                     <then xsi:type="If">
                        <condition asType="t:Boolean" xsi:type="As">
                           <operand xsi:type="Or">
                              <operand path="durationAlreadyParsed" scope="S" xsi:type="Property"/>
                              <operand xsi:type="Matches">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand xsi:type="Concatenate">
                                                <operand xsi:type="Concatenate">
                                                   <operand xsi:type="Concatenate">
                                                      <operand xsi:type="Concatenate">
                                                         <operand valueType="t:String" value=".*?\b" xsi:type="Literal"/>
                                                         <operand name="prefixRegex" xsi:type="OperandRef"/>
                                                      </operand>
                                                      <operand valueType="t:String" value=" *\d+ *" xsi:type="Literal"/>
                                                   </operand>
                                                   <operand name="suffixRegex" xsi:type="OperandRef"/>
                                                </operand>
                                                <operand valueType="t:String" value="\b.*?\b" xsi:type="Literal"/>
                                             </operand>
                                             <operand name="prefixRegex" xsi:type="OperandRef"/>
                                          </operand>
                                          <operand valueType="t:String" value=" *\d+ *" xsi:type="Literal"/>
                                       </operand>
                                       <operand name="suffixRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value="\b.*" xsi:type="Literal"/>
                                 </operand>
                              </operand>
                           </operand>
                        </condition>
                        <then xsi:type="Tuple">
                           <element name="duration">
                              <value strict="false" xsi:type="As">
                                 <operand xsi:type="Null"/>
                                 <asTypeSpecifier name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                              </value>
                           </element>
                           <element name="durationTimeUnits">
                              <value strict="false" xsi:type="As">
                                 <operand xsi:type="Null"/>
                                 <asTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
                              </value>
                           </element>
                           <element name="leftover">
                              <value name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand name="prefixRegex" xsi:type="OperandRef"/>
                                       <operand valueType="t:String" value=" *\d+ *" xsi:type="Literal"/>
                                    </operand>
                                    <operand name="suffixRegex" xsi:type="OperandRef"/>
                                 </operand>
                                 <operand valueType="t:String" value="" xsi:type="Literal"/>
                              </value>
                           </element>
                           <element name="durationAlreadyParsed">
                              <value valueType="t:Boolean" value="true" xsi:type="Literal"/>
                           </element>
                        </then>
                        <else xsi:type="Tuple">
                           <element name="duration">
                              <value xsi:type="ToInteger">
                                 <operand xsi:type="ReplaceMatches">
                                    <operand path="leftover" scope="S" xsi:type="Property"/>
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand xsi:type="Concatenate">
                                                <operand valueType="t:String" value=".*?\b" xsi:type="Literal"/>
                                                <operand name="prefixRegex" xsi:type="OperandRef"/>
                                             </operand>
                                             <operand valueType="t:String" value=" *(\d+) *" xsi:type="Literal"/>
                                          </operand>
                                          <operand name="suffixRegex" xsi:type="OperandRef"/>
                                       </operand>
                                       <operand valueType="t:String" value="\b.*" xsi:type="Literal"/>
                                    </operand>
                                    <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                                 </operand>
                              </value>
                           </element>
                           <element name="durationTimeUnits">
                              <value name="unitsLabel" xsi:type="OperandRef"/>
                           </element>
                           <element name="leftover">
                              <value name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand name="prefixRegex" xsi:type="OperandRef"/>
                                       <operand valueType="t:String" value=" *\d+ *" xsi:type="Literal"/>
                                    </operand>
                                    <operand name="suffixRegex" xsi:type="OperandRef"/>
                                 </operand>
                                 <operand valueType="t:String" value="" xsi:type="Literal"/>
                              </value>
                           </element>
                           <element name="durationAlreadyParsed">
                              <value valueType="t:Boolean" value="true" xsi:type="Literal"/>
                           </element>
                        </else>
                     </then>
                     <else name="S" xsi:type="AliasRef"/>
                  </expression>
               </return>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="duration">
                     <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="durationTimeUnits">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="durationAlreadyParsed">
                     <type name="t:Boolean" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="prefixRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="suffixRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="unitsLabel">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="DoseUnitsOpts" context="Population" accessLevel="Private">
         <expression valueType="t:String" value="tab|pill|capsule|patch|film|mg|mcg|ml|cc|tsp" xsi:type="Literal"/>
      </def>
      <def name="NullIfEmptyString" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="If">
            <condition asType="t:Boolean" xsi:type="As">
               <operand xsi:type="Equivalent">
                  <operand name="value" xsi:type="OperandRef"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </operand>
            </condition>
            <then asType="t:String" xsi:type="As">
               <operand xsi:type="Null"/>
            </then>
            <else name="value" xsi:type="OperandRef"/>
         </expression>
         <operand name="value">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ProcessWordDailyMax" context="Population" accessLevel="Private" xsi:type="FunctionDef">
         <expression xsi:type="SingletonFrom">
            <operand xsi:type="Query">
               <source alias="S">
                  <expression name="states" xsi:type="OperandRef"/>
               </source>
               <return>
                  <expression xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Matches">
                           <operand path="leftover" scope="S" xsi:type="Property"/>
                           <operand xsi:type="Concatenate">
                              <operand xsi:type="Concatenate">
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand valueType="t:String" value=".*?(?&lt;!w)" xsi:type="Literal"/>
                                       <operand name="prefixRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value=" ?\d+ ?x ?" xsi:type="Literal"/>
                                 </operand>
                                 <operand name="suffixRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="(?!w).*" xsi:type="Literal"/>
                           </operand>
                        </operand>
                     </condition>
                     <then xsi:type="Tuple">
                        <element name="maxDailyFrequency">
                           <value xsi:type="ToInteger">
                              <operand xsi:type="ReplaceMatches">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand valueType="t:String" value=".*?(?&lt;!w)" xsi:type="Literal"/>
                                             <operand name="prefixRegex" xsi:type="OperandRef"/>
                                          </operand>
                                          <operand valueType="t:String" value=" ?(\d+) ?x ?" xsi:type="Literal"/>
                                       </operand>
                                       <operand name="suffixRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value="(?!w).*" xsi:type="Literal"/>
                                 </operand>
                                 <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                              </operand>
                           </value>
                        </element>
                        <element name="maxDailyDose">
                           <value path="maxDailyDose" scope="S" xsi:type="Property"/>
                        </element>
                        <element name="maxDailyDoseUnits">
                           <value path="maxDailyDoseUnits" scope="S" xsi:type="Property"/>
                        </element>
                        <element name="leftover">
                           <value name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                              <operand path="leftover" scope="S" xsi:type="Property"/>
                              <operand xsi:type="Concatenate">
                                 <operand xsi:type="Concatenate">
                                    <operand name="prefixRegex" xsi:type="OperandRef"/>
                                    <operand valueType="t:String" value=" ?\d+ ?x ?" xsi:type="Literal"/>
                                 </operand>
                                 <operand name="suffixRegex" xsi:type="OperandRef"/>
                              </operand>
                              <operand valueType="t:String" value="" xsi:type="Literal"/>
                           </value>
                        </element>
                     </then>
                     <else xsi:type="If">
                        <condition asType="t:Boolean" xsi:type="As">
                           <operand xsi:type="Matches">
                              <operand path="leftover" scope="S" xsi:type="Property"/>
                              <operand xsi:type="Concatenate">
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand xsi:type="Concatenate">
                                                <operand valueType="t:String" value=".*?(?&lt;!w)" xsi:type="Literal"/>
                                                <operand name="prefixRegex" xsi:type="OperandRef"/>
                                             </operand>
                                             <operand valueType="t:String" value=" ?\d+\.?\d* ?(?:" xsi:type="Literal"/>
                                          </operand>
                                          <operand name="DoseUnitsOpts" xsi:type="ExpressionRef"/>
                                       </operand>
                                       <operand valueType="t:String" value=")? ?" xsi:type="Literal"/>
                                    </operand>
                                    <operand name="suffixRegex" xsi:type="OperandRef"/>
                                 </operand>
                                 <operand valueType="t:String" value="(?!w).*" xsi:type="Literal"/>
                              </operand>
                           </operand>
                        </condition>
                        <then xsi:type="Tuple">
                           <element name="maxDailyFrequency">
                              <value path="maxDailyFrequency" scope="S" xsi:type="Property"/>
                           </element>
                           <element name="maxDailyDose">
                              <value xsi:type="ToDecimal">
                                 <operand xsi:type="ReplaceMatches">
                                    <operand path="leftover" scope="S" xsi:type="Property"/>
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand xsi:type="Concatenate">
                                                <operand xsi:type="Concatenate">
                                                   <operand xsi:type="Concatenate">
                                                      <operand valueType="t:String" value=".*?(?&lt;!w)" xsi:type="Literal"/>
                                                      <operand name="prefixRegex" xsi:type="OperandRef"/>
                                                   </operand>
                                                   <operand valueType="t:String" value=" ?(\d+\.?\d*) ?(?:" xsi:type="Literal"/>
                                                </operand>
                                                <operand name="DoseUnitsOpts" xsi:type="ExpressionRef"/>
                                             </operand>
                                             <operand valueType="t:String" value=")? ?" xsi:type="Literal"/>
                                          </operand>
                                          <operand name="suffixRegex" xsi:type="OperandRef"/>
                                       </operand>
                                       <operand valueType="t:String" value="(?!w).*" xsi:type="Literal"/>
                                    </operand>
                                    <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                                 </operand>
                              </value>
                           </element>
                           <element name="maxDailyDoseUnits">
                              <value name="NullIfEmptyString" xsi:type="FunctionRef">
                                 <operand xsi:type="ReplaceMatches">
                                    <operand path="leftover" scope="S" xsi:type="Property"/>
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand xsi:type="Concatenate">
                                                <operand xsi:type="Concatenate">
                                                   <operand xsi:type="Concatenate">
                                                      <operand valueType="t:String" value=".*?(?&lt;!w)" xsi:type="Literal"/>
                                                      <operand name="prefixRegex" xsi:type="OperandRef"/>
                                                   </operand>
                                                   <operand valueType="t:String" value=" ?\d+\.?\d* ?(" xsi:type="Literal"/>
                                                </operand>
                                                <operand name="DoseUnitsOpts" xsi:type="ExpressionRef"/>
                                             </operand>
                                             <operand valueType="t:String" value=")? ?" xsi:type="Literal"/>
                                          </operand>
                                          <operand name="suffixRegex" xsi:type="OperandRef"/>
                                       </operand>
                                       <operand valueType="t:String" value="(?!w).*" xsi:type="Literal"/>
                                    </operand>
                                    <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                                 </operand>
                              </value>
                           </element>
                           <element name="leftover">
                              <value xsi:type="ReplaceMatches">
                                 <operand path="leftover" scope="S" xsi:type="Property"/>
                                 <operand xsi:type="Concatenate">
                                    <operand xsi:type="Concatenate">
                                       <operand xsi:type="Concatenate">
                                          <operand xsi:type="Concatenate">
                                             <operand xsi:type="Concatenate">
                                                <operand xsi:type="Concatenate">
                                                   <operand valueType="t:String" value="(?&lt;!w)" xsi:type="Literal"/>
                                                   <operand name="prefixRegex" xsi:type="OperandRef"/>
                                                </operand>
                                                <operand valueType="t:String" value=" ?\d+\.?\d* ?(?:" xsi:type="Literal"/>
                                             </operand>
                                             <operand name="DoseUnitsOpts" xsi:type="ExpressionRef"/>
                                          </operand>
                                          <operand valueType="t:String" value=")? ?" xsi:type="Literal"/>
                                       </operand>
                                       <operand name="suffixRegex" xsi:type="OperandRef"/>
                                    </operand>
                                    <operand valueType="t:String" value="(?!w)" xsi:type="Literal"/>
                                 </operand>
                                 <operand valueType="t:String" value="" xsi:type="Literal"/>
                              </value>
                           </element>
                        </then>
                        <else name="S" xsi:type="AliasRef"/>
                     </else>
                  </expression>
               </return>
            </operand>
         </expression>
         <operand name="states">
            <operandTypeSpecifier xsi:type="ListTypeSpecifier">
               <elementType xsi:type="TupleTypeSpecifier">
                  <element name="maxDailyFrequency">
                     <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="maxDailyDose">
                     <type name="t:Decimal" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="maxDailyDoseUnits">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
                  <element name="leftover">
                     <type name="t:String" xsi:type="NamedTypeSpecifier"/>
                  </element>
               </elementType>
            </operandTypeSpecifier>
         </operand>
         <operand name="prefixRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
         <operand name="suffixRegex">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
      <def name="ParsedFreeTextSIG" context="Population" accessLevel="Public" xsi:type="FunctionDef">
         <expression xsi:type="Query">
            <source alias="origSig">
               <expression name="SIG" xsi:type="OperandRef"/>
            </source>
            <let identifier="normSig_Argument">
               <expression name="origSig" xsi:type="AliasRef"/>
            </let>
            <let identifier="normSig_FilterByCharWhitelist">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_Argument" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="[^ 0-9A-Z_a-z,;:!\.'&quot;()@*/&amp;#%+-]" xsi:type="Literal"/>
                  <operand valueType="t:String" value=" " xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Lowercase">
               <expression xsi:type="Lower">
                  <operand name="normSig_FilterByCharWhitelist" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="indication_EarlyStageCheck">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="EndsWith">
                        <operand name="normSig_Lowercase" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value=", pain" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then valueType="t:String" value="pain" xsi:type="Literal"/>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="normSig_ChopSfxPain">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_Lowercase" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value=", pain$" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_DropMorePunct">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_ChopSfxPain" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="[,!*:;]" xsi:type="Literal"/>
                  <operand valueType="t:String" value=" " xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_DropNoise">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_DropMorePunct" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:of|please|the|with)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_MergeHyphens">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_DropNoise" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="-( *-)+" xsi:type="Literal"/>
                  <operand valueType="t:String" value="-" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Plurals">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_MergeHyphens" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?&lt;=[a-z])\(s\)(?![a-z])" xsi:type="Literal"/>
                  <operand valueType="t:String" value="s" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers11">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Plurals" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="two and( (a|one))? half" xsi:type="Literal"/>
                  <operand valueType="t:String" value="2.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers12">
               <expression name="ReplaceMatchesDigitWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers11" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="2 (1/2|0.5)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="2.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers21">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers12" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="one and( (a|one))? half" xsi:type="Literal"/>
                  <operand valueType="t:String" value="1.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers22">
               <expression name="ReplaceMatchesDigitWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers21" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="1 (1/2|0.5)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="1.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers31">
               <expression name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers22" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:one|1)[ -]half" xsi:type="Literal"/>
                  <operand valueType="t:String" value="0.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers32">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers31" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="half" xsi:type="Literal"/>
                  <operand valueType="t:String" value="0.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers33">
               <expression name="ReplaceMatchesDigitWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers32" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="1/2" xsi:type="Literal"/>
                  <operand valueType="t:String" value="0.5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers41">
               <expression name="ReplaceMatchesAlphaDigitWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers33" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:one|1)[ -]fourth" xsi:type="Literal"/>
                  <operand valueType="t:String" value="0.25" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers51">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers41" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="one( full)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="1" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers52">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers51" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="two" xsi:type="Literal"/>
                  <operand valueType="t:String" value="2" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers53">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers52" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="three" xsi:type="Literal"/>
                  <operand valueType="t:String" value="3" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers54">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers53" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="four" xsi:type="Literal"/>
                  <operand valueType="t:String" value="4" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers55">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers54" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="five" xsi:type="Literal"/>
                  <operand valueType="t:String" value="5" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers56">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers55" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="six" xsi:type="Literal"/>
                  <operand valueType="t:String" value="6" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers57">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers56" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="seven" xsi:type="Literal"/>
                  <operand valueType="t:String" value="7" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers58">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers57" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="eight" xsi:type="Literal"/>
                  <operand valueType="t:String" value="8" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers59">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers58" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="nine" xsi:type="Literal"/>
                  <operand valueType="t:String" value="9" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers510">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers59" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="ten" xsi:type="Literal"/>
                  <operand valueType="t:String" value="10" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers511">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers510" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="eleven" xsi:type="Literal"/>
                  <operand valueType="t:String" value="11" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers512">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers511" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="twelve" xsi:type="Literal"/>
                  <operand valueType="t:String" value="12" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Numbers61">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Numbers512" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(\d+) \(\1\)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Range">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_Numbers61" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(\d+\.?\d*) *(?:to|-|or) *(\d+\.?\d*)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1-$2" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency1">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Range" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="times" xsi:type="Literal"/>
                  <operand valueType="t:String" value="x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency2">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Frequency1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="once" xsi:type="Literal"/>
                  <operand valueType="t:String" value="1x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency3">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Frequency2" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:twice|bid)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="2x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency4">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Frequency3" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:thrice|tid)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="3x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency5">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Frequency4" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="qid" xsi:type="Literal"/>
                  <operand valueType="t:String" value="4x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency6">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_Frequency5" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(\d+) *x" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Frequency7">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_Frequency6" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(\d+)x?-(\d+)x" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1-$2x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Clean1">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="normSig_Frequency7" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="fillDate_Argument">
               <expression name="normSig_Clean1" xsi:type="QueryLetRef"/>
            </let>
            <let identifier="fillDate_Pattern">
               <expression valueType="t:String" value="(?:earliest fill date|to be filled on(?: or after)?|(?:ok to|may) fill(?: on)?) +(?&lt;month>\d+)/(?&lt;day>\d+)/(?&lt;year>\d+)" xsi:type="Literal"/>
            </let>
            <let identifier="fillDate_PatternWithRest">
               <expression xsi:type="Concatenate">
                  <operand xsi:type="Concatenate">
                     <operand valueType="t:String" value=".*?" xsi:type="Literal"/>
                     <operand name="fillDate_Pattern" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value=".*" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="fillDate_IsMatch">
               <expression xsi:type="Matches">
                  <operand name="fillDate_Argument" xsi:type="QueryLetRef"/>
                  <operand name="fillDate_PatternWithRest" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="fillDate_DateParts">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="fillDate_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="Tuple">
                     <element name="year">
                        <value name="NormalizeYear" xsi:type="FunctionRef">
                           <operand xsi:type="ToInteger">
                              <operand xsi:type="ReplaceMatches">
                                 <operand name="fillDate_Argument" xsi:type="QueryLetRef"/>
                                 <operand name="fillDate_PatternWithRest" xsi:type="QueryLetRef"/>
                                 <operand valueType="t:String" value="${year}" xsi:type="Literal"/>
                              </operand>
                           </operand>
                        </value>
                     </element>
                     <element name="month">
                        <value xsi:type="ToInteger">
                           <operand xsi:type="ReplaceMatches">
                              <operand name="fillDate_Argument" xsi:type="QueryLetRef"/>
                              <operand name="fillDate_PatternWithRest" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="${month}" xsi:type="Literal"/>
                           </operand>
                        </value>
                     </element>
                     <element name="day">
                        <value xsi:type="ToInteger">
                           <operand xsi:type="ReplaceMatches">
                              <operand name="fillDate_Argument" xsi:type="QueryLetRef"/>
                              <operand name="fillDate_PatternWithRest" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="${day}" xsi:type="Literal"/>
                           </operand>
                        </value>
                     </element>
                  </then>
                  <else xsi:type="As">
                     <operand xsi:type="Null"/>
                     <asTypeSpecifier xsi:type="TupleTypeSpecifier">
                        <element name="year">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                        <element name="month">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                        <element name="day">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                     </asTypeSpecifier>
                  </else>
               </expression>
            </let>
            <let identifier="fillDate">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="fillDate_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="DateTime">
                     <year path="year" xsi:type="Property">
                        <source name="fillDate_DateParts" xsi:type="QueryLetRef"/>
                     </year>
                     <month path="month" xsi:type="Property">
                        <source name="fillDate_DateParts" xsi:type="QueryLetRef"/>
                     </month>
                     <day path="day" xsi:type="Property">
                        <source name="fillDate_DateParts" xsi:type="QueryLetRef"/>
                     </day>
                  </then>
                  <else asType="t:DateTime" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="normSig_FillDate">
               <expression xsi:type="ReplaceMatches">
                  <operand name="fillDate_Argument" xsi:type="QueryLetRef"/>
                  <operand name="fillDate_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Clean2">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="normSig_FillDate" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="useDates_Argument">
               <expression name="normSig_Clean2" xsi:type="QueryLetRef"/>
            </let>
            <let identifier="useDates_Pattern">
               <expression valueType="t:String" value="(?:(?:for )?use dates|for use|dates) +(?&lt;startMonth>\d+)/(?&lt;startDay>\d+)(?:/(?&lt;startYear>\d+))? *- *(?&lt;endMonth>\d+)/(?&lt;endDay>\d+)/(?&lt;endYear>\d+)" xsi:type="Literal"/>
            </let>
            <let identifier="useDates_PatternWithRest">
               <expression xsi:type="Concatenate">
                  <operand xsi:type="Concatenate">
                     <operand valueType="t:String" value=".*?" xsi:type="Literal"/>
                     <operand name="useDates_Pattern" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value=".*" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="useDates_IsMatch">
               <expression xsi:type="Matches">
                  <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                  <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="useDates_EndDateParts">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="useDates_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="Tuple">
                     <element name="year">
                        <value name="NormalizeYear" xsi:type="FunctionRef">
                           <operand xsi:type="ToInteger">
                              <operand xsi:type="ReplaceMatches">
                                 <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                                 <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
                                 <operand valueType="t:String" value="${endYear}" xsi:type="Literal"/>
                              </operand>
                           </operand>
                        </value>
                     </element>
                     <element name="month">
                        <value xsi:type="ToInteger">
                           <operand xsi:type="ReplaceMatches">
                              <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                              <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="${endMonth}" xsi:type="Literal"/>
                           </operand>
                        </value>
                     </element>
                     <element name="day">
                        <value xsi:type="ToInteger">
                           <operand xsi:type="ReplaceMatches">
                              <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                              <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="${endDay}" xsi:type="Literal"/>
                           </operand>
                        </value>
                     </element>
                  </then>
                  <else xsi:type="As">
                     <operand xsi:type="Null"/>
                     <asTypeSpecifier xsi:type="TupleTypeSpecifier">
                        <element name="year">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                        <element name="month">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                        <element name="day">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                     </asTypeSpecifier>
                  </else>
               </expression>
            </let>
            <let identifier="useDates_MaybeStartYear">
               <expression xsi:type="ReplaceMatches">
                  <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                  <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="${startYear}" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="useDates_StartDateParts">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="useDates_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="Tuple">
                     <element name="year">
                        <value xsi:type="If">
                           <condition asType="t:Boolean" xsi:type="As">
                              <operand xsi:type="Equal">
                                 <operand name="useDates_MaybeStartYear" xsi:type="QueryLetRef"/>
                                 <operand valueType="t:String" value="" xsi:type="Literal"/>
                              </operand>
                           </condition>
                           <then path="year" xsi:type="Property">
                              <source name="useDates_EndDateParts" xsi:type="QueryLetRef"/>
                           </then>
                           <else name="NormalizeYear" xsi:type="FunctionRef">
                              <operand xsi:type="ToInteger">
                                 <operand name="useDates_MaybeStartYear" xsi:type="QueryLetRef"/>
                              </operand>
                           </else>
                        </value>
                     </element>
                     <element name="month">
                        <value xsi:type="ToInteger">
                           <operand xsi:type="ReplaceMatches">
                              <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                              <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="${startMonth}" xsi:type="Literal"/>
                           </operand>
                        </value>
                     </element>
                     <element name="day">
                        <value xsi:type="ToInteger">
                           <operand xsi:type="ReplaceMatches">
                              <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                              <operand name="useDates_PatternWithRest" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="${startDay}" xsi:type="Literal"/>
                           </operand>
                        </value>
                     </element>
                  </then>
                  <else xsi:type="As">
                     <operand xsi:type="Null"/>
                     <asTypeSpecifier xsi:type="TupleTypeSpecifier">
                        <element name="year">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                        <element name="month">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                        <element name="day">
                           <type name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                        </element>
                     </asTypeSpecifier>
                  </else>
               </expression>
            </let>
            <let identifier="endDate">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="useDates_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="DateTime">
                     <year path="year" xsi:type="Property">
                        <source name="useDates_EndDateParts" xsi:type="QueryLetRef"/>
                     </year>
                     <month path="month" xsi:type="Property">
                        <source name="useDates_EndDateParts" xsi:type="QueryLetRef"/>
                     </month>
                     <day path="day" xsi:type="Property">
                        <source name="useDates_EndDateParts" xsi:type="QueryLetRef"/>
                     </day>
                  </then>
                  <else asType="t:DateTime" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="useDates_StartDateNonAdjusted">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="useDates_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="DateTime">
                     <year path="year" xsi:type="Property">
                        <source name="useDates_StartDateParts" xsi:type="QueryLetRef"/>
                     </year>
                     <month path="month" xsi:type="Property">
                        <source name="useDates_StartDateParts" xsi:type="QueryLetRef"/>
                     </month>
                     <day path="day" xsi:type="Property">
                        <source name="useDates_StartDateParts" xsi:type="QueryLetRef"/>
                     </day>
                  </then>
                  <else asType="t:DateTime" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="startDate">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="useDates_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="After">
                           <operand name="useDates_StartDateNonAdjusted" xsi:type="QueryLetRef"/>
                           <operand name="endDate" xsi:type="QueryLetRef"/>
                        </operand>
                     </condition>
                     <then xsi:type="Subtract">
                        <operand name="useDates_StartDateNonAdjusted" xsi:type="QueryLetRef"/>
                        <operand value="1" unit="year" xsi:type="Quantity"/>
                     </then>
                     <else name="useDates_StartDateNonAdjusted" xsi:type="QueryLetRef"/>
                  </then>
                  <else asType="t:DateTime" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="normSig_UseDates">
               <expression xsi:type="ReplaceMatches">
                  <operand name="useDates_Argument" xsi:type="QueryLetRef"/>
                  <operand name="useDates_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Clean3">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="normSig_UseDates" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="normSig_Take">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Clean3" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="takes" xsi:type="Literal"/>
                  <operand valueType="t:String" value="take" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Q">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Take" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="eve(?:ry|r|y)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="q" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Tab">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Q" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:tab(?:let)?s?|full tab)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="tab" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Pill">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Tab" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="pills" xsi:type="Literal"/>
                  <operand valueType="t:String" value="pill" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Capsule">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Pill" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="capsules" xsi:type="Literal"/>
                  <operand valueType="t:String" value="capsule" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Puff">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Capsule" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="puffs" xsi:type="Literal"/>
                  <operand valueType="t:String" value="puff" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Tsp">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Puff" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:teaspoon(?:full?)?s?|tsps|tspfull?)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="tsp" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Patch">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Tsp" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="patches" xsi:type="Literal"/>
                  <operand valueType="t:String" value="patch" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_OnePatch">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Patch" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="apply patch" xsi:type="Literal"/>
                  <operand valueType="t:String" value="apply 1 patch" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Film">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_OnePatch" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="films" xsi:type="Literal"/>
                  <operand valueType="t:String" value="film" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Measures">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Film" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(mg|mcg|ml|cc)s" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Hr">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Measures" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="h(?:ou)?rs?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="hr" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Day">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Hr" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="days" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Week">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Day" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="w(?:ee)?ks?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Month">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Week" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="mo(?:nth)?s?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Prn1">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Month" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:only )?(?:as|if) (?:need(?:ed)?|necessary)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="prn" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Prn2">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Prn1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="prn prn" xsi:type="Literal"/>
                  <operand valueType="t:String" value="prn" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_PO">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Prn2" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:by mouths?|orally|po po)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="po" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_SL">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_PO" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:sublingual|under tongue)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="sl" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Tube">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_SL" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="per feeding tube" xsi:type="Literal"/>
                  <operand valueType="t:String" value="feeding tube" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Skin1">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Tube" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:externally )?to skin" xsi:type="Literal"/>
                  <operand valueType="t:String" value="skin" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Skin2">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Skin1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:and change|to be applied)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryDay">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Skin2" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:daily|(?:a|per) day|q ?day|qd)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every day" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryAft">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryDay" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="in afternoon" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every afternoon" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryNight1">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryAft" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:q ?|in )(evening|hs|night|pm)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every night" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryNight2">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryNight1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:hs|(?&lt;!\d)pm|nightly)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every night" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryNight3">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryNight2" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:at|before|every) (bed|night)( ?time)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every night" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryNight4">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryNight3" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="every (?:night|day) every night" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every night" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryMorn1">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryNight4" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:(?:q ?|in )(?:morning|am)|(?&lt;!\d)am)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every morning" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_EveryMorn2">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryMorn1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="every (?:day every morning|morning every day)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every morning" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Combo3">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_EveryMorn2" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="every morning and every night" xsi:type="Literal"/>
                  <operand valueType="t:String" value="2x" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_Clean4">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="normSig_Combo3" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="normSig_A">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_Clean4" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="a" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_An">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="normSig_A" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="an" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_ExcessHyphen">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_An" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(\d+ ?)-( ?\D)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1$2" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_MergeSpaces">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_ExcessHyphen" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value=" {2,}" xsi:type="Literal"/>
                  <operand valueType="t:String" value=" " xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_TrimSpaces1">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_MergeSpaces" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="^ *(.*?) *$" xsi:type="Literal"/>
                  <operand valueType="t:String" value="$1" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig_TrimSpaces2">
               <expression xsi:type="ReplaceMatches">
                  <operand name="normSig_TrimSpaces1" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="\( *(.*?) *\)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="($1)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="normSig">
               <expression name="normSig_TrimSpaces2" xsi:type="QueryLetRef"/>
            </let>
            <let identifier="leftoverSig_Argument">
               <expression name="normSig" xsi:type="QueryLetRef"/>
            </let>
            <let identifier="ignorSig_Argument">
               <expression xsi:type="Tuple">
                  <element name="ignorable">
                     <value strict="false" xsi:type="As">
                        <operand xsi:type="Null"/>
                        <asTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
                     </value>
                  </element>
                  <element name="leftover">
                     <value name="leftoverSig_Argument" xsi:type="QueryLetRef"/>
                  </element>
               </expression>
            </let>
            <let identifier="ignorSig_11">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_Argument" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="do not combine other tylenol products" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_12">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_11" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="can take stool softener if constipation occurs" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_13">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_12" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="may cause drowsiness" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_14">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_13" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:as it )?(?:may sedate|is sedating)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_15">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_14" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="may fill early for travel" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_21">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_15" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="do not drive on medication" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_22">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_21" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must be seen for further refills" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_23">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_22" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="may (?:re)?fil.+?(?:(?:before|prior to) use dates?|day prior|fill date|same day|today)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_24">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_23" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="not valid without seal" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_25">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_24" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="bring to appointment" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_31">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_25" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="needs.+?brand" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_32">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_31" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="this is(?: a)?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_33">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_32" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="no early refills" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_34">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_33" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="do not fill early" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_35">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_34" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="attending to sign" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_41">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_35" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="no further refills from pmc" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_42">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_41" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:use )?as directed" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_43">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_42" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="wean asap" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_44">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_43" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:and )?change" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_51">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_44" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="avoid with driving or work" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_52">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_51" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="try to minimize overall" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_53">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_52" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="but" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_54">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_53" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="self pay(?: portion)?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_55">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_54" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="insurance portion" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_61">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_55" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="instructions in spanish" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_62">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_61" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="do not combine" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_63">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_62" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="day time" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_64">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_63" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="daw" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_65">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_64" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="alternate.+?(?:oxy|hydro)codone" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_71">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_65" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="brand.+?(?:necessary|only)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_72">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_71" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="do not.+?(?:sedate|on med(?:ication)?)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_73">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_72" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="prior.+?skin care" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_74">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_73" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:do not exceed|max).+?acetaminophen.+?(?:24 ?hr|day)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_75">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_74" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="dr.+?to sign only" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_81">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_75" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="please notify.+?ready" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig_82">
               <expression name="ProcessIgnorableWordPhrase" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="ignorSig_81" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:hydro|r?oxy)codone" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="ignorSig">
               <expression path="ignorable" xsi:type="Property">
                  <source name="ignorSig_82" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="leftoverSig_SansIgnorables">
               <expression path="leftover" xsi:type="Property">
                  <source name="ignorSig_82" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="command_Argument">
               <expression name="leftoverSig_SansIgnorables" xsi:type="QueryLetRef"/>
            </let>
            <let identifier="command_Pattern">
               <expression valueType="t:String" value="^((?:to )?(?:apply|dissolve|place|take)|may take|take up to)(?![a-z])" xsi:type="Literal"/>
            </let>
            <let identifier="command">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="Matches">
                        <operand name="command_Argument" xsi:type="QueryLetRef"/>
                        <operand xsi:type="Concatenate">
                           <operand name="command_Pattern" xsi:type="QueryLetRef"/>
                           <operand valueType="t:String" value=".*" xsi:type="Literal"/>
                        </operand>
                     </operand>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="command_Argument" xsi:type="QueryLetRef"/>
                     <operand xsi:type="Concatenate">
                        <operand xsi:type="Concatenate">
                           <operand valueType="t:String" value="(" xsi:type="Literal"/>
                           <operand name="command_Pattern" xsi:type="QueryLetRef"/>
                        </operand>
                        <operand valueType="t:String" value=").*" xsi:type="Literal"/>
                     </operand>
                     <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                  </then>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="leftoverSig_Command">
               <expression xsi:type="ReplaceMatches">
                  <operand name="command_Argument" xsi:type="QueryLetRef"/>
                  <operand name="command_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn_Argument">
               <expression xsi:type="Tuple">
                  <element name="isPrn">
                     <value valueType="t:Boolean" value="false" xsi:type="Literal"/>
                  </element>
                  <element name="indication">
                     <value name="indication_EarlyStageCheck" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="leftover">
                     <value name="leftoverSig_Command" xsi:type="QueryLetRef"/>
                  </element>
               </expression>
            </let>
            <let identifier="isPrn_1">
               <expression name="ProcessWordPrnReasonWithLabel" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_Argument" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value=".*?pain(?: control)?" xsi:type="Literal"/>
                  <operand xsi:type="ToList">
                     <operand valueType="t:String" value="pain" xsi:type="Literal"/>
                  </operand>
               </expression>
            </let>
            <let identifier="isPrn_2">
               <expression name="ProcessWordPrnReason" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_1" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="cough and congestion" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn_3">
               <expression name="ProcessWordPrnReason" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_2" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="headaches?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn_4">
               <expression name="ProcessWordPrnReason" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_3" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="nausea and stomach cramps" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn_5">
               <expression name="ProcessWordPrnReasonWithLabel" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_4" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value=".*?cough" xsi:type="Literal"/>
                  <operand xsi:type="ToList">
                     <operand valueType="t:String" value="cough" xsi:type="Literal"/>
                  </operand>
               </expression>
            </let>
            <let identifier="isPrn_6">
               <expression name="ProcessWordPrnReason" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_5" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:restless leg(?: syndrome|s)|rls)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn_7">
               <expression name="ProcessWordPrnReason" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="isPrn_6" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="opioid dependence" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn_MainChecks">
               <expression path="isPrn" xsi:type="Property">
                  <source name="isPrn_7" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="indication_Argument">
               <expression xsi:type="Tuple">
                  <element name="indication">
                     <value path="indication" xsi:type="Property">
                        <source name="isPrn_7" xsi:type="QueryLetRef"/>
                     </value>
                  </element>
                  <element name="leftover">
                     <value path="leftover" xsi:type="Property">
                        <source name="isPrn_7" xsi:type="QueryLetRef"/>
                     </value>
                  </element>
               </expression>
            </let>
            <let identifier="indication_1">
               <expression name="ProcessWordIndicationWithLabel" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="indication_Argument" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value=".*?pain(?: control)?" xsi:type="Literal"/>
                  <operand xsi:type="ToList">
                     <operand valueType="t:String" value="pain" xsi:type="Literal"/>
                  </operand>
               </expression>
            </let>
            <let identifier="indication_2">
               <expression name="ProcessWordIndication" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="indication_1" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="cough(?: and congestion)?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="indication_3">
               <expression name="ProcessWordIndication" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="indication_2" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="headaches?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="indication_4">
               <expression name="ProcessWordIndication" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="indication_3" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="nausea and stomach cramps" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="indication_5">
               <expression name="ProcessWordIndication" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="indication_4" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:restless leg(?: syndrome|s)|rls)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="indication_6">
               <expression name="ProcessWordIndication" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="indication_5" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="opioid dependence" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="indication">
               <expression path="indication" xsi:type="Property">
                  <source name="indication_6" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="duration_Argument">
               <expression xsi:type="Tuple">
                  <element name="duration">
                     <value strict="false" xsi:type="As">
                        <operand xsi:type="Null"/>
                        <asTypeSpecifier name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                     </value>
                  </element>
                  <element name="durationTimeUnits">
                     <value strict="false" xsi:type="As">
                        <operand xsi:type="Null"/>
                        <asTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
                     </value>
                  </element>
                  <element name="leftover">
                     <value path="leftover" xsi:type="Property">
                        <source name="indication_6" xsi:type="QueryLetRef"/>
                     </value>
                  </element>
                  <element name="durationAlreadyParsed">
                     <value valueType="t:Boolean" value="false" xsi:type="Literal"/>
                  </element>
               </expression>
            </let>
            <let identifier="duration_11">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_Argument" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day(?: (?:supply|rx))?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_12">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_11" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week(?: (?:supply|rx))?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_13">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_12" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month(?: (?:supply|rx))?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_21">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_13" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="each rx should last for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_22">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_21" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="each rx should last for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_23">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_22" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="each rx should last for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_31">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_23" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must last at least(?: to last)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_32">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_31" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must last at least(?: to last)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_33">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_32" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must last at least(?: to last)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_41">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_33" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="each fill must last" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_42">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_41" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="each fill must last" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_43">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_42" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="each fill must last" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_51">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_43" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must last?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_52">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_51" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must last?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_53">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_52" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="must last?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_61">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_53" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="to last(?: at least)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_62">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_61" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="to last(?: at least)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_63">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_62" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="to last(?: at least)?" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_71">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_63" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day (?:supply|rx)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_72">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_71" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week (?:supply|rx)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_73">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_72" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month (?:supply|rx)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_81">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_73" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="x" xsi:type="Literal"/>
                  <operand valueType="t:String" value="day" xsi:type="Literal"/>
                  <operand valueType="t:String" value="d" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_82">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_81" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="x" xsi:type="Literal"/>
                  <operand valueType="t:String" value="week" xsi:type="Literal"/>
                  <operand valueType="t:String" value="wk" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration_83">
               <expression name="ProcessWordDuration" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="duration_82" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="x" xsi:type="Literal"/>
                  <operand valueType="t:String" value="month" xsi:type="Literal"/>
                  <operand valueType="t:String" value="mo" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="duration">
               <expression path="duration" xsi:type="Property">
                  <source name="duration_83" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="durationTimeUnits">
               <expression path="durationTimeUnits" xsi:type="Property">
                  <source name="duration_83" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="dailyMax_Argument">
               <expression xsi:type="Tuple">
                  <element name="maxDailyFrequency">
                     <value strict="false" xsi:type="As">
                        <operand xsi:type="Null"/>
                        <asTypeSpecifier name="t:Integer" xsi:type="NamedTypeSpecifier"/>
                     </value>
                  </element>
                  <element name="maxDailyDose">
                     <value strict="false" xsi:type="As">
                        <operand xsi:type="Null"/>
                        <asTypeSpecifier name="t:Decimal" xsi:type="NamedTypeSpecifier"/>
                     </value>
                  </element>
                  <element name="maxDailyDoseUnits">
                     <value strict="false" xsi:type="As">
                        <operand xsi:type="Null"/>
                        <asTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
                     </value>
                  </element>
                  <element name="leftover">
                     <value path="leftover" xsi:type="Property">
                        <source name="duration_83" xsi:type="QueryLetRef"/>
                     </value>
                  </element>
               </expression>
            </let>
            <let identifier="dailyMax_commonSuffixRegex">
               <expression valueType="t:String" value="(?:(?:in )?every day|/?day|(?:in )?24 ?hr|per 24hr day)" xsi:type="Literal"/>
            </let>
            <let identifier="dailyMax_1">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_Argument" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:(?:for|up ?to) )?(?:max(?:imum)?|ave(?:rage)?|avg)" xsi:type="Literal"/>
                  <operand name="dailyMax_commonSuffixRegex" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="dailyMax_2">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_1" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:do not|not to|to) exceed" xsi:type="Literal"/>
                  <operand name="dailyMax_commonSuffixRegex" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="dailyMax_3">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_2" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="total" xsi:type="Literal"/>
                  <operand name="dailyMax_commonSuffixRegex" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="dailyMax_4">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_3" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="(?:(?:limit|for) )?up ?to" xsi:type="Literal"/>
                  <operand name="dailyMax_commonSuffixRegex" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="dailyMax_5">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_4" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="for" xsi:type="Literal"/>
                  <operand valueType="t:String" value="(?:every day|/day|(?:in )?24 ?hr|per 24hr day)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dailyMax_6">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_5" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="\(" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every day\)" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dailyMax_7">
               <expression name="ProcessWordDailyMax" xsi:type="FunctionRef">
                  <operand xsi:type="ToList">
                     <operand name="dailyMax_6" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value="or" xsi:type="Literal"/>
                  <operand valueType="t:String" value="every day" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="maxDailyFrequency">
               <expression path="maxDailyFrequency" xsi:type="Property">
                  <source name="dailyMax_7" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="maxDailyDose">
               <expression path="maxDailyDose" xsi:type="Property">
                  <source name="dailyMax_7" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="maxDailyDoseUnits">
               <expression path="maxDailyDoseUnits" xsi:type="Property">
                  <source name="dailyMax_7" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="route_Argument">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand path="leftover" xsi:type="Property">
                     <source name="dailyMax_7" xsi:type="QueryLetRef"/>
                  </operand>
               </expression>
            </let>
            <let identifier="route">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="Matches">
                        <operand name="route_Argument" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value=".*?(?&lt;![a-z])(?:po|sl|skin|feeding tube)(?![a-z]).*" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="route_Argument" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value=".*?(?&lt;![a-z])(po|sl|skin|feeding tube)(?![a-z]).*" xsi:type="Literal"/>
                     <operand valueType="t:String" value="$1" xsi:type="Literal"/>
                  </then>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="leftoverSig_Route">
               <expression name="ReplaceMatchesAlphaWord" xsi:type="FunctionRef">
                  <operand name="route_Argument" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="(?:po|sl|skin|feeding tube)" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dosing_Argument">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="leftoverSig_Route" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="dosing_Pattern">
               <expression xsi:type="Concatenate">
                  <operand xsi:type="Concatenate">
                     <operand xsi:type="Concatenate">
                        <operand xsi:type="Concatenate">
                           <operand xsi:type="Concatenate">
                              <operand xsi:type="Concatenate">
                                 <operand valueType="t:String" value="^" xsi:type="Literal"/>
                                 <operand valueType="t:String" value="(?&lt;doseLow>\d+\.?\d*)(?:-(?&lt;doseHigh>\d+\.?\d*))? ?(?&lt;doseUnits>" xsi:type="Literal"/>
                              </operand>
                              <operand name="DoseUnitsOpts" xsi:type="ExpressionRef"/>
                           </operand>
                           <operand valueType="t:String" value=")?" xsi:type="Literal"/>
                        </operand>
                        <operand valueType="t:String" value=" ?(?:\((?&lt;altDoseSig>" xsi:type="Literal"/>
                     </operand>
                     <operand valueType="t:String" value=".*" xsi:type="Literal"/>
                  </operand>
                  <operand valueType="t:String" value=")\))?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dosing_PatternWithRest">
               <expression xsi:type="Concatenate">
                  <operand name="dosing_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value=".*" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="dosing_IsMatch">
               <expression xsi:type="Matches">
                  <operand name="dosing_Argument" xsi:type="QueryLetRef"/>
                  <operand name="dosing_PatternWithRest" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="doseLow">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="dosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ToDecimal">
                     <operand xsi:type="ReplaceMatches">
                        <operand name="dosing_Argument" xsi:type="QueryLetRef"/>
                        <operand name="dosing_PatternWithRest" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="${doseLow}" xsi:type="Literal"/>
                     </operand>
                  </then>
                  <else asType="t:Decimal" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="doseHighStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="dosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="dosing_Argument" xsi:type="QueryLetRef"/>
                     <operand name="dosing_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${doseHigh}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="doseHigh">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="Equal">
                        <operand name="doseHighStr" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then name="doseLow" xsi:type="QueryLetRef"/>
                  <else xsi:type="ToDecimal">
                     <operand name="doseHighStr" xsi:type="QueryLetRef"/>
                  </else>
               </expression>
            </let>
            <let identifier="doseUnits">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="dosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then name="NullIfEmptyString" xsi:type="FunctionRef">
                     <operand xsi:type="ReplaceMatches">
                        <operand name="dosing_Argument" xsi:type="QueryLetRef"/>
                        <operand name="dosing_PatternWithRest" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="${doseUnits}" xsi:type="Literal"/>
                     </operand>
                  </then>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="altDoseSig">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="dosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="dosing_Argument" xsi:type="QueryLetRef"/>
                     <operand name="dosing_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${altDoseSig}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="altDosing_Pattern">
               <expression xsi:type="Concatenate">
                  <operand xsi:type="Concatenate">
                     <operand valueType="t:String" value="(?&lt;altDoseLow>\d+\.?\d*)(?:-(?&lt;altDoseHigh>\d+\.?\d*))? ?(?&lt;altDoseUnits>" xsi:type="Literal"/>
                     <operand name="DoseUnitsOpts" xsi:type="ExpressionRef"/>
                  </operand>
                  <operand valueType="t:String" value=")?" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="altDosing_PatternWithRest">
               <expression xsi:type="Concatenate">
                  <operand name="altDosing_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value=".*" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="altDosing_IsMatch">
               <expression xsi:type="Matches">
                  <operand name="altDoseSig" xsi:type="QueryLetRef"/>
                  <operand name="altDosing_PatternWithRest" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="altDoseLow">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="altDosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ToDecimal">
                     <operand xsi:type="ReplaceMatches">
                        <operand name="altDoseSig" xsi:type="QueryLetRef"/>
                        <operand name="altDosing_PatternWithRest" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="${altDoseLow}" xsi:type="Literal"/>
                     </operand>
                  </then>
                  <else asType="t:Decimal" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="altDoseHighStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="altDosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="altDoseSig" xsi:type="QueryLetRef"/>
                     <operand name="altDosing_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${altDoseHigh}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="altDoseHigh">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="Equal">
                        <operand name="altDoseHighStr" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then name="altDoseLow" xsi:type="QueryLetRef"/>
                  <else xsi:type="ToDecimal">
                     <operand name="altDoseHighStr" xsi:type="QueryLetRef"/>
                  </else>
               </expression>
            </let>
            <let identifier="altDoseUnits">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="altDosing_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then name="NullIfEmptyString" xsi:type="FunctionRef">
                     <operand xsi:type="ReplaceMatches">
                        <operand name="altDoseSig" xsi:type="QueryLetRef"/>
                        <operand name="altDosing_PatternWithRest" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="${altDoseUnits}" xsi:type="Literal"/>
                     </operand>
                  </then>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="leftoverSig_Dosing">
               <expression xsi:type="ReplaceMatches">
                  <operand name="dosing_Argument" xsi:type="QueryLetRef"/>
                  <operand name="dosing_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="interval_Argument">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="leftoverSig_Dosing" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="interval_Pattern">
               <expression valueType="t:String" value="\bq ?(?&lt;intervalLow>\d+)(?:-(?&lt;intervalHigh>\d+))? ?(?&lt;intervalTimeUnits>hr?|month|week|day|prn)?\b" xsi:type="Literal"/>
            </let>
            <let identifier="interval_PatternWithRest">
               <expression xsi:type="Concatenate">
                  <operand xsi:type="Concatenate">
                     <operand valueType="t:String" value=".*?" xsi:type="Literal"/>
                     <operand name="interval_Pattern" xsi:type="QueryLetRef"/>
                  </operand>
                  <operand valueType="t:String" value=".*" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="interval_IsMatch">
               <expression xsi:type="Matches">
                  <operand name="interval_Argument" xsi:type="QueryLetRef"/>
                  <operand name="interval_PatternWithRest" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="intervalLow">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="interval_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ToInteger">
                     <operand xsi:type="ReplaceMatches">
                        <operand name="interval_Argument" xsi:type="QueryLetRef"/>
                        <operand name="interval_PatternWithRest" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="${intervalLow}" xsi:type="Literal"/>
                     </operand>
                  </then>
                  <else asType="t:Integer" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="intervalHighStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="interval_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="interval_Argument" xsi:type="QueryLetRef"/>
                     <operand name="interval_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${intervalHigh}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="intervalHigh">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="Equal">
                        <operand name="intervalHighStr" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then name="intervalLow" xsi:type="QueryLetRef"/>
                  <else xsi:type="ToInteger">
                     <operand name="intervalHighStr" xsi:type="QueryLetRef"/>
                  </else>
               </expression>
            </let>
            <let identifier="intervalTimeUnitsStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="interval_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="interval_Argument" xsi:type="QueryLetRef"/>
                     <operand name="interval_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${intervalTimeUnits}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="intervalTimeUnits">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="interval_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="In">
                           <operand name="intervalTimeUnitsStr" xsi:type="QueryLetRef"/>
                           <operand xsi:type="List">
                              <element valueType="t:String" value="" xsi:type="Literal"/>
                              <element valueType="t:String" value="h" xsi:type="Literal"/>
                              <element valueType="t:String" value="hr" xsi:type="Literal"/>
                              <element valueType="t:String" value="prn" xsi:type="Literal"/>
                           </operand>
                        </operand>
                     </condition>
                     <then valueType="t:String" value="h" xsi:type="Literal"/>
                     <else xsi:type="If">
                        <condition asType="t:Boolean" xsi:type="As">
                           <operand xsi:type="Equal">
                              <operand name="intervalTimeUnitsStr" xsi:type="QueryLetRef"/>
                              <operand valueType="t:String" value="day" xsi:type="Literal"/>
                           </operand>
                        </condition>
                        <then valueType="t:String" value="d" xsi:type="Literal"/>
                        <else name="intervalTimeUnitsStr" xsi:type="QueryLetRef"/>
                     </else>
                  </then>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="isPrn_Interval">
               <expression xsi:type="Or">
                  <operand name="isPrn_MainChecks" xsi:type="QueryLetRef"/>
                  <operand xsi:type="Equal">
                     <operand name="intervalTimeUnitsStr" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="prn" xsi:type="Literal"/>
                  </operand>
               </expression>
            </let>
            <let identifier="leftoverSig_Interval">
               <expression xsi:type="ReplaceMatches">
                  <operand name="interval_Argument" xsi:type="QueryLetRef"/>
                  <operand name="interval_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="frequency_Argument">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="leftoverSig_Interval" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="frequency_Pattern">
               <expression valueType="t:String" value="^(?:prn)? ?(?&lt;frequencyRange>(?&lt;frequencyLow>\d+)x?(?:-(?&lt;frequencyHigh>\d+))?x)? ?(?:(?&lt;frequencyTimeUnits>every (?:day|night|morning)|prn)|$)" xsi:type="Literal"/>
            </let>
            <let identifier="frequency_PatternWithRest">
               <expression xsi:type="Concatenate">
                  <operand name="frequency_Pattern" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value=".*" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="frequency_IsMatch">
               <expression xsi:type="Matches">
                  <operand name="frequency_Argument" xsi:type="QueryLetRef"/>
                  <operand name="frequency_PatternWithRest" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="frequency_Range">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="frequency_Argument" xsi:type="QueryLetRef"/>
                     <operand name="frequency_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${frequencyRange}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="frequencyLowStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="frequency_Argument" xsi:type="QueryLetRef"/>
                     <operand name="frequency_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${frequencyLow}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="frequencyHighStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="frequency_Argument" xsi:type="QueryLetRef"/>
                     <operand name="frequency_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${frequencyHigh}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="frequencyTimeUnitsStr">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_IsMatch" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="frequency_Argument" xsi:type="QueryLetRef"/>
                     <operand name="frequency_PatternWithRest" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="${frequencyTimeUnits}" xsi:type="Literal"/>
                  </then>
                  <else valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="frequency_HaveResult">
               <expression xsi:type="And">
                  <operand name="frequency_IsMatch" xsi:type="QueryLetRef"/>
                  <operand xsi:type="Or">
                     <operand xsi:type="Not">
                        <operand xsi:type="Equal">
                           <operand name="frequency_Range" xsi:type="QueryLetRef"/>
                           <operand valueType="t:String" value="" xsi:type="Literal"/>
                        </operand>
                     </operand>
                     <operand xsi:type="StartsWith">
                        <operand name="frequencyTimeUnitsStr" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="every" xsi:type="Literal"/>
                     </operand>
                  </operand>
               </expression>
            </let>
            <let identifier="frequencyLow">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_HaveResult" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Equal">
                           <operand name="frequencyLowStr" xsi:type="QueryLetRef"/>
                           <operand valueType="t:String" value="" xsi:type="Literal"/>
                        </operand>
                     </condition>
                     <then valueType="t:Integer" value="1" xsi:type="Literal"/>
                     <else xsi:type="ToInteger">
                        <operand name="frequencyLowStr" xsi:type="QueryLetRef"/>
                     </else>
                  </then>
                  <else asType="t:Integer" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="frequencyHigh">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_HaveResult" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="If">
                     <condition asType="t:Boolean" xsi:type="As">
                        <operand xsi:type="Equal">
                           <operand name="frequencyHighStr" xsi:type="QueryLetRef"/>
                           <operand valueType="t:String" value="" xsi:type="Literal"/>
                        </operand>
                     </condition>
                     <then name="frequencyLow" xsi:type="QueryLetRef"/>
                     <else xsi:type="ToInteger">
                        <operand name="frequencyHighStr" xsi:type="QueryLetRef"/>
                     </else>
                  </then>
                  <else asType="t:Integer" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="frequencyTimeUnits">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_HaveResult" xsi:type="QueryLetRef"/>
                  </condition>
                  <then valueType="t:String" value="d" xsi:type="Literal"/>
                  <else asType="t:String" xsi:type="As">
                     <operand xsi:type="Null"/>
                  </else>
               </expression>
            </let>
            <let identifier="isPrn_Frequency">
               <expression xsi:type="Or">
                  <operand name="isPrn_Interval" xsi:type="QueryLetRef"/>
                  <operand xsi:type="And">
                     <operand name="frequency_HaveResult" xsi:type="QueryLetRef"/>
                     <operand xsi:type="Equal">
                        <operand name="frequencyTimeUnitsStr" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="prn" xsi:type="Literal"/>
                     </operand>
                  </operand>
               </expression>
            </let>
            <let identifier="leftoverSig_Frequency">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand name="frequency_HaveResult" xsi:type="QueryLetRef"/>
                  </condition>
                  <then xsi:type="ReplaceMatches">
                     <operand name="frequency_Argument" xsi:type="QueryLetRef"/>
                     <operand name="frequency_Pattern" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="" xsi:type="Literal"/>
                  </then>
                  <else name="frequency_Argument" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="cleanup_Argument">
               <expression name="CleanedStr" xsi:type="FunctionRef">
                  <operand name="leftoverSig_Frequency" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <let identifier="isPrn_Cleanup">
               <expression xsi:type="Or">
                  <operand name="isPrn_Frequency" xsi:type="QueryLetRef"/>
                  <operand xsi:type="Matches">
                     <operand name="cleanup_Argument" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value=".*? *(?&lt;![a-z])prn" xsi:type="Literal"/>
                  </operand>
               </expression>
            </let>
            <let identifier="leftoverSig_Cleanup">
               <expression xsi:type="ReplaceMatches">
                  <operand name="cleanup_Argument" xsi:type="QueryLetRef"/>
                  <operand valueType="t:String" value=" *(?&lt;![a-z])prn$" xsi:type="Literal"/>
                  <operand valueType="t:String" value="" xsi:type="Literal"/>
               </expression>
            </let>
            <let identifier="isPrn">
               <expression xsi:type="Or">
                  <operand name="isPrn_Cleanup" xsi:type="QueryLetRef"/>
                  <operand xsi:type="Equal">
                     <operand name="leftoverSig_Cleanup" xsi:type="QueryLetRef"/>
                     <operand valueType="t:String" value="prn (" xsi:type="Literal"/>
                  </operand>
               </expression>
            </let>
            <let identifier="leftoverSig">
               <expression xsi:type="If">
                  <condition asType="t:Boolean" xsi:type="As">
                     <operand xsi:type="Matches">
                        <operand name="leftoverSig_Cleanup" xsi:type="QueryLetRef"/>
                        <operand valueType="t:String" value="(?:prn \(|\(|\))" xsi:type="Literal"/>
                     </operand>
                  </condition>
                  <then valueType="t:String" value="" xsi:type="Literal"/>
                  <else name="leftoverSig_Cleanup" xsi:type="QueryLetRef"/>
               </expression>
            </let>
            <return>
               <expression xsi:type="Tuple">
                  <element name="alternateDoseHigh">
                     <value name="altDoseHigh" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="alternateDoseLow">
                     <value name="altDoseLow" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="alternateDoseUnits">
                     <value name="altDoseUnits" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="command">
                     <value name="command" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="doseHigh">
                     <value name="doseHigh" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="doseLow">
                     <value name="doseLow" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="doseUnits">
                     <value name="doseUnits" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="duration">
                     <value name="duration" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="durationTimeUnits">
                     <value name="durationTimeUnits" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="earliestFillDate">
                     <value name="fillDate" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="endDate">
                     <value name="endDate" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="frequencyHigh">
                     <value name="frequencyHigh" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="frequencyLow">
                     <value name="frequencyLow" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="frequencyTimeUnits">
                     <value name="frequencyTimeUnits" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="ignorableSig">
                     <value name="ignorSig" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="indication">
                     <value name="indication" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="intervalHigh">
                     <value name="intervalHigh" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="intervalLow">
                     <value name="intervalLow" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="intervalTimeUnits">
                     <value name="intervalTimeUnits" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="isPrn">
                     <value name="isPrn" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="leftoverSig">
                     <value name="leftoverSig" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="maxDailyDose">
                     <value name="maxDailyDose" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="maxDailyDoseUnits">
                     <value name="maxDailyDoseUnits" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="maxDailyFrequency">
                     <value name="maxDailyFrequency" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="normalizedSig">
                     <value name="normSig" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="originalSig">
                     <value name="origSig" xsi:type="AliasRef"/>
                  </element>
                  <element name="route">
                     <value name="route" xsi:type="QueryLetRef"/>
                  </element>
                  <element name="startDate">
                     <value name="startDate" xsi:type="QueryLetRef"/>
                  </element>
               </expression>
            </return>
         </expression>
         <operand name="SIG">
            <operandTypeSpecifier name="t:String" xsi:type="NamedTypeSpecifier"/>
         </operand>
      </def>
   </statements>
</library>


